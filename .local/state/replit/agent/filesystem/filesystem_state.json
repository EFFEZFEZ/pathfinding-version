{"file_contents":{"public/data/README.md":{"content":"# Donn√©es GTFS et GeoJSON\n\nPlacez vos fichiers ici pour que l'application puisse les charger.\n\n## üìÅ Structure attendue\n\n```\n/public/data/\n  ‚îú‚îÄ‚îÄ gtfs/\n  ‚îÇ   ‚îú‚îÄ‚îÄ routes.txt          (Obligatoire)\n  ‚îÇ   ‚îú‚îÄ‚îÄ trips.txt           (Obligatoire)\n  ‚îÇ   ‚îú‚îÄ‚îÄ stop_times.txt      (Obligatoire)\n  ‚îÇ   ‚îú‚îÄ‚îÄ stops.txt           (Obligatoire)\n  ‚îÇ   ‚îú‚îÄ‚îÄ calendar.txt        (Optionnel)\n  ‚îÇ   ‚îî‚îÄ‚îÄ shapes.txt          (Optionnel)\n  ‚îî‚îÄ‚îÄ map.geojson             (Obligatoire pour l'affichage des lignes)\n```\n\n## üìã Fichiers GTFS requis\n\n### routes.txt\nD√©finit les lignes de bus\n- `route_id` - Identifiant unique de la ligne\n- `route_short_name` - Nom court (ex: \"12\")\n- `route_long_name` - Nom complet (ex: \"Gare - Centre Ville\")\n- `route_color` - Couleur en hexad√©cimal (optionnel)\n\n### trips.txt\nD√©finit les courses individuelles\n- `trip_id` - Identifiant unique de la course\n- `route_id` - R√©f√©rence vers routes.txt\n- `trip_headsign` - Destination affich√©e\n\n### stop_times.txt\nD√©finit les horaires √† chaque arr√™t\n- `trip_id` - R√©f√©rence vers trips.txt\n- `arrival_time` - Heure d'arriv√©e (HH:MM:SS)\n- `departure_time` - Heure de d√©part (HH:MM:SS)\n- `stop_id` - R√©f√©rence vers stops.txt\n- `stop_sequence` - Ordre de l'arr√™t dans la course\n\n### stops.txt\nD√©finit les arr√™ts\n- `stop_id` - Identifiant unique de l'arr√™t\n- `stop_name` - Nom de l'arr√™t\n- `stop_lat` - Latitude\n- `stop_lon` - Longitude\n\n## üó∫Ô∏è Fichier GeoJSON\n\nLe fichier `map.geojson` doit contenir les trac√©s des lignes de bus au format GeoJSON.\n\nExemple de structure:\n```json\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {\n        \"name\": \"Ligne 12\",\n        \"route_id\": \"12\",\n        \"color\": \"#ff5722\"\n      },\n      \"geometry\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n          [2.3522, 48.8566],\n          [2.3530, 48.8575]\n        ]\n      }\n    }\n  ]\n}\n```\n\n## üöÄ Apr√®s avoir ajout√© vos fichiers\n\n1. Rafra√Æchissez la page web\n2. L'application chargera automatiquement vos donn√©es\n3. Cliquez sur \"Play\" pour voir les bus en mouvement\n","size_bytes":2150},"public/js/busPositionCalculator.js":{"content":"/**\n * busPositionCalculator.js\n * \n * Calcule les positions g√©ographiques interpol√©es des bus entre deux arr√™ts\n */\n\nexport class BusPositionCalculator {\n    constructor(dataManager) {\n        this.dataManager = dataManager;\n    }\n\n    /**\n     * Calcule la position interpol√©e d'un bus entre deux arr√™ts\n     * Utilise le trac√© GeoJSON de la route si disponible, sinon interpolation lin√©aire\n     */\n    calculatePosition(segment, routeId = null) {\n        if (!segment || !segment.fromStopInfo || !segment.toStopInfo) {\n            return null;\n        }\n\n        const fromLat = parseFloat(segment.fromStopInfo.stop_lat);\n        const fromLon = parseFloat(segment.fromStopInfo.stop_lon);\n        const toLat = parseFloat(segment.toStopInfo.stop_lat);\n        const toLon = parseFloat(segment.toStopInfo.stop_lon);\n\n        // V√©rifier que les coordonn√©es sont valides\n        if (isNaN(fromLat) || isNaN(fromLon) || isNaN(toLat) || isNaN(toLon)) {\n            console.warn('Coordonn√©es invalides pour les arr√™ts:', segment);\n            return null;\n        }\n\n        const progress = segment.progress;\n\n        // Tenter d'utiliser le trac√© GeoJSON si disponible\n        if (routeId) {\n            const routeGeometry = this.dataManager.getRouteGeometry(routeId);\n            if (routeGeometry && routeGeometry.length > 0) {\n                const position = this.interpolateAlongRoute(\n                    routeGeometry, \n                    fromLat, fromLon, \n                    toLat, toLon, \n                    progress\n                );\n                if (position) {\n                    // Log pour confirmer que le trac√© GeoJSON est utilis√©\n                    if (Math.random() < 0.01) { // Log 1% du temps pour ne pas surcharger\n                        console.log(`‚úì Bus suit le trac√© GeoJSON de la route ${routeId}`);\n                    }\n                    return position;\n                }\n            } else if (routeId && Math.random() < 0.01) {\n                console.log(`‚ö†Ô∏è Pas de trac√© GeoJSON pour route ${routeId}, utilisation fallback lin√©aire`);\n            }\n        }\n\n        // Fallback: Interpolation lin√©aire si pas de trac√© GeoJSON\n        const lat = fromLat + (toLat - fromLat) * progress;\n        const lon = fromLon + (toLon - fromLon) * progress;\n\n        return {\n            lat,\n            lon,\n            progress\n        };\n    }\n\n    /**\n     * Interpole la position le long d'un trac√© GeoJSON\n     */\n    interpolateAlongRoute(routeCoordinates, fromLat, fromLon, toLat, toLon, progress) {\n        // Trouver les points du trac√© les plus proches des arr√™ts de d√©part et d'arriv√©e\n        const fromIndex = this.dataManager.findNearestPointOnRoute(routeCoordinates, fromLat, fromLon);\n        const toIndex = this.dataManager.findNearestPointOnRoute(routeCoordinates, toLat, toLon);\n\n        if (fromIndex === null || toIndex === null || fromIndex === toIndex) {\n            return null; // Pas de segment valide sur le trac√©\n        }\n\n        // D√©terminer la direction (aller ou retour)\n        const direction = fromIndex < toIndex ? 1 : -1;\n        const startIndex = fromIndex;\n        const endIndex = toIndex;\n\n        // Extraire le segment du trac√© entre les deux arr√™ts\n        let pathSegment;\n        if (direction > 0) {\n            pathSegment = routeCoordinates.slice(startIndex, endIndex + 1);\n        } else {\n            pathSegment = routeCoordinates.slice(endIndex, startIndex + 1).reverse();\n        }\n\n        if (pathSegment.length < 2) {\n            return null;\n        }\n\n        // Calculer les distances cumul√©es le long du trac√©\n        const distances = [0];\n        for (let i = 1; i < pathSegment.length; i++) {\n            const [lon1, lat1] = pathSegment[i - 1];\n            const [lon2, lat2] = pathSegment[i];\n            const dist = this.dataManager.calculateDistance(lat1, lon1, lat2, lon2);\n            distances.push(distances[i - 1] + dist);\n        }\n\n        const totalDistance = distances[distances.length - 1];\n        if (totalDistance === 0) {\n            return null;\n        }\n\n        // Trouver la distance cible selon la progression\n        const targetDistance = totalDistance * progress;\n\n        // Trouver le segment o√π se trouve le bus\n        for (let i = 0; i < pathSegment.length - 1; i++) {\n            if (targetDistance >= distances[i] && targetDistance <= distances[i + 1]) {\n                const segmentDistance = distances[i + 1] - distances[i];\n                const segmentProgress = segmentDistance > 0 \n                    ? (targetDistance - distances[i]) / segmentDistance \n                    : 0;\n\n                const [lon1, lat1] = pathSegment[i];\n                const [lon2, lat2] = pathSegment[i + 1];\n\n                // Interpolation lin√©aire sur ce segment du trac√©\n                const lat = lat1 + (lat2 - lat1) * segmentProgress;\n                const lon = lon1 + (lon2 - lon1) * segmentProgress;\n\n                return {\n                    lat,\n                    lon,\n                    progress\n                };\n            }\n        }\n\n        // Si on arrive ici, retourner le dernier point\n        const [lon, lat] = pathSegment[pathSegment.length - 1];\n        return { lat, lon, progress };\n    }\n\n    /**\n     * Calcule l'angle de d√©placement du bus (pour orienter l'ic√¥ne)\n     */\n    calculateBearing(segment) {\n        if (!segment || !segment.fromStopInfo || !segment.toStopInfo) {\n            return 0;\n        }\n\n        const fromLat = parseFloat(segment.fromStopInfo.stop_lat);\n        const fromLon = parseFloat(segment.fromStopInfo.stop_lon);\n        const toLat = parseFloat(segment.toStopInfo.stop_lat);\n        const toLon = parseFloat(segment.toStopInfo.stop_lon);\n\n        // Convertir les coordonn√©es en radians pour les calculs trigonom√©triques\n        const fromLatRad = this.toRad(fromLat);\n        const fromLonRad = this.toRad(fromLon);\n        const toLatRad = this.toRad(toLat);\n        const toLonRad = this.toRad(toLon);\n\n        // Calcul de l'angle en degr√©s\n        const dLon = toLonRad - fromLonRad;\n        const y = Math.sin(dLon) * Math.cos(toLatRad);\n        const x = Math.cos(fromLatRad) * Math.sin(toLatRad) -\n                  Math.sin(fromLatRad) * Math.cos(toLatRad) * Math.cos(dLon);\n        \n        const bearing = Math.atan2(y, x);\n        const degrees = (bearing * 180 / Math.PI + 360) % 360;\n        \n        return degrees;\n    }\n\n    /**\n     * Calcule toutes les positions pour les bus actifs\n     */\n    calculateAllPositions(activeBuses) {\n        return activeBuses.map(bus => {\n            // Passer le route_id pour utiliser le trac√© GeoJSON\n            const routeId = bus.route?.route_id;\n            const position = this.calculatePosition(bus.segment, routeId);\n            const bearing = this.calculateBearing(bus.segment);\n\n            if (!position) {\n                return null;\n            }\n\n            return {\n                ...bus,\n                position,\n                bearing\n            };\n        }).filter(bus => bus !== null);\n    }\n\n    /**\n     * Calcule la distance entre deux points (formule de Haversine)\n     * Utile pour des optimisations futures\n     */\n    calculateDistance(lat1, lon1, lat2, lon2) {\n        const R = 6371; // Rayon de la Terre en km\n        const dLat = this.toRad(lat2 - lat1);\n        const dLon = this.toRad(lon2 - lon1);\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        \n        return distance;\n    }\n\n    /**\n     * Convertit des degr√©s en radians\n     */\n    toRad(degrees) {\n        return degrees * Math.PI / 180;\n    }\n}\n","size_bytes":7920},"public/js/timeManager.js":{"content":"/**\n * timeManager.js\n * \n * G√®re le temps r√©el pour l'affichage des bus en circulation\n */\n\nexport class TimeManager {\n    constructor() {\n        this.isRunning = false;\n        this.listeners = [];\n    }\n\n    /**\n     * R√©cup√®re l'heure r√©elle actuelle\n     */\n    getRealTime() {\n        const now = new Date();\n        const hours = now.getHours();\n        const minutes = now.getMinutes();\n        const seconds = now.getSeconds();\n        \n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    /**\n     * D√©marre le mode temps r√©el\n     */\n    play() {\n        if (!this.isRunning) {\n            this.isRunning = true;\n            this.tick();\n            console.log('‚ñ∂Ô∏è Mode temps r√©el d√©marr√©');\n        }\n    }\n\n    /**\n     * Met en pause la mise √† jour\n     */\n    pause() {\n        this.isRunning = false;\n        console.log('‚è∏Ô∏è Mode temps r√©el en pause');\n    }\n\n    /**\n     * Red√©marre le mode temps r√©el\n     */\n    reset() {\n        console.log('üîÑ Rechargement du temps r√©el');\n        this.notifyListeners();\n    }\n\n    /**\n     * Boucle principale de mise √† jour du temps r√©el\n     */\n    tick() {\n        if (!this.isRunning) return;\n\n        // Mettre √† jour avec l'heure r√©elle\n        this.notifyListeners();\n\n        // Continuer la boucle (mise √† jour toutes les secondes)\n        setTimeout(() => this.tick(), 1000);\n    }\n\n    /**\n     * Ajoute un listener pour les changements de temps\n     */\n    addListener(callback) {\n        this.listeners.push(callback);\n    }\n\n    /**\n     * Notifie tous les listeners avec l'heure r√©elle\n     */\n    notifyListeners() {\n        const currentSeconds = this.getRealTime();\n        const timeInfo = {\n            seconds: currentSeconds,\n            timeString: this.formatTime(currentSeconds),\n            isRunning: this.isRunning,\n            date: new Date()\n        };\n\n        this.listeners.forEach(callback => {\n            callback(timeInfo);\n        });\n    }\n\n    /**\n     * Formate les secondes en HH:MM:SS\n     */\n    formatTime(seconds) {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        const secs = Math.floor(seconds % 60);\n        \n        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;\n    }\n\n    /**\n     * R√©cup√®re le temps actuel en secondes (heure r√©elle)\n     */\n    getCurrentSeconds() {\n        return this.getRealTime();\n    }\n\n    /**\n     * R√©cup√®re le temps actuel en format HH:MM:SS (heure r√©elle)\n     */\n    getCurrentTimeString() {\n        return this.formatTime(this.getRealTime());\n    }\n\n    /**\n     * V√©rifie si le mode temps r√©el est actif\n     */\n    getIsRunning() {\n        return this.isRunning;\n    }\n}\n","size_bytes":2803},"public/js/main.js":{"content":"/**\n * mapRenderer.js\n * G√®re toutes les interactions avec Leaflet.\n */\n\nexport class MapRenderer {\n    constructor(mapContainerId) {\n        this.map = null;\n        this.mapContainerId = mapContainerId;\n        this.busMarkers = new Map(); // Stocke les marqueurs par trip_id\n        this.markerLayer = new L.LayerGroup();\n        this.geoJsonLayer = null;\n        this.popupChangeCallback = () => {}; // Fonction pour notifier l'App\n    }\n\n    initializeMap() {\n        this.map = L.map(this.mapContainerId).setView([45.18, 0.72], 13); // Centr√© sur P√©rigueux\n        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n            attribution: '¬© OpenStreetMap contributors'\n        }).addTo(this.map);\n\n        this.map.addLayer(this.markerLayer);\n    }\n\n    setPopupChangeListener(callback) {\n        this.popupChangeCallback = callback;\n    }\n\n    // ... (Fonctions utilitaires : createBusIcon, createPopupContent)\n\n    /**\n     * Cr√©e l'ic√¥ne de bus personnalis√©e.\n     */\n    createBusIcon(shortName) {\n        return L.divIcon({\n            className: 'bus-icon',\n            iconSize: [32, 32],\n            iconAnchor: [16, 16],\n            html: `<span>${shortName}</span>` // Optionnel : utiliser le shortName si l'ic√¥ne est trop petite\n        });\n    }\n\n    /**\n     * Cr√©e le contenu HTML du popup du bus.\n     */\n    createPopupContent(bus, tripScheduler, currentSeconds) {\n        const route = bus.route;\n        const stopInfo = tripScheduler.getNextStopInfo(bus.trip.trip_id, currentSeconds);\n\n        let nextStopHtml = 'N/A';\n        if (stopInfo) {\n            const timeDiff = stopInfo.nextDepartureTime - currentSeconds;\n            const minutes = Math.floor(timeDiff / 60);\n            nextStopHtml = `Prochain arr√™t : <strong>${stopInfo.nextStopName}</strong> (dans ${minutes} min)`;\n        }\n\n        return `\n            <div class=\"bus-popup\">\n                <h4>Ligne ${route.route_short_name}</h4>\n                <p>Destination : <strong>${bus.trip.trip_headsign}</strong></p>\n                <p>${nextStopHtml}</p>\n            </div>\n        `;\n    }\n\n    /**\n     * Affiche les routes GeoJSON filtr√©es.\n     */\n    displayMultiColorRoutes(geoJson, dataManager, visibleRoutes) {\n        if (this.geoJsonLayer) {\n            this.map.removeLayer(this.geoJsonLayer);\n        }\n\n        this.geoJsonLayer = L.geoJSON(geoJson, {\n            filter: function(feature) {\n                // Filtrer les routes non visibles\n                return visibleRoutes.has(feature.properties.route_id);\n            },\n            style: function(feature) {\n                const routeId = feature.properties.route_id;\n                const route = dataManager.getRoute(routeId);\n                const color = route ? `#${route.route_color}` : '#3388ff';\n\n                return {\n                    color: color,\n                    weight: 4,\n                    opacity: 0.7\n                };\n            }\n        }).addTo(this.map);\n    }\n\n    /**\n     * Met √† jour les marqueurs de bus sur la carte.\n     */\n    updateBusMarkers(busesWithPositions, tripScheduler, currentSeconds, openTripId) {\n        const activeTripIds = new Set();\n\n        busesWithPositions.forEach(bus => {\n            const tripId = bus.trip.trip_id;\n            activeTripIds.add(tripId);\n            let marker = this.busMarkers.get(tripId);\n\n            // Cr√©er ou mettre √† jour le marqueur\n            if (!marker) {\n                // Cr√©ation du marqueur\n                marker = L.marker([bus.lat, bus.lon], {\n                    icon: this.createBusIcon(bus.route.route_short_name)\n                });\n\n                // Attacher les listeners de popup √† la cr√©ation pour suivre l'√©tat global\n                marker.on('popupopen', () => this.popupChangeCallback(tripId));\n                marker.on('popupclose', () => this.popupChangeCallback(null));\n\n                marker.addTo(this.markerLayer);\n                this.busMarkers.set(tripId, marker);\n            } else {\n                // Mise √† jour de la position\n                marker.setLatLng([bus.lat, bus.lon]);\n            }\n\n            // Mettre √† jour le contenu du popup (important pour le temps r√©el)\n            const popupContent = this.createPopupContent(bus, tripScheduler, currentSeconds);\n            marker.bindPopup(popupContent, { \n                className: 'bus-popup',\n                autoClose: false // Permet de garder le popup ouvert sans avoir √† cliquer sur le marqueur\n            });\n\n            // Forcer la r√©ouverture si cet ID est celui qui doit rester ouvert\n            if (openTripId === tripId) {\n                if (!marker.getPopup().isOpen()) {\n                    marker.openPopup();\n                }\n            }\n        });\n\n        // Supprimer les marqueurs des bus qui ne sont plus actifs\n        const markersToRemove = [];\n        this.busMarkers.forEach((marker, tripId) => {\n            if (!activeTripIds.has(tripId)) {\n                markersToRemove.push(marker);\n                this.busMarkers.delete(tripId);\n\n                // Si on retire le bus dont le popup √©tait ouvert, on le notifie\n                if (tripId === openTripId) {\n                    this.popupChangeCallback(null);\n                }\n            }\n        });\n\n        markersToRemove.forEach(marker => {\n            this.markerLayer.removeLayer(marker);\n        });\n    }\n\n    /**\n     * Retourne le nombre de bus affich√©s\n     */\n    getBusCount() {\n        return this.busMarkers.size;\n    }\n}","size_bytes":5540},"public/js/tripScheduler.js":{"content":"/**\n * tripScheduler.js\n * \n * Calcule les trajets actifs √† un instant T donn√©\n */\n\nexport class TripScheduler {\n    constructor(dataManager) {\n        this.dataManager = dataManager;\n    }\n\n    /**\n     * R√©cup√®re tous les bus actifs au temps donn√©\n     * Retourne un tableau d'objets avec les informations de position\n     */\n    getActiveBuses(currentSeconds) {\n        if (!this.dataManager.isLoaded) {\n            return [];\n        }\n\n        const activeTrips = this.dataManager.getActiveTrips(currentSeconds);\n        const activeBuses = [];\n\n        activeTrips.forEach(({ tripId, trip, stopTimes, route }) => {\n            // Trouver entre quels arr√™ts se trouve le bus\n            const segment = this.findCurrentSegment(stopTimes, currentSeconds);\n            \n            if (segment) {\n                activeBuses.push({\n                    tripId,\n                    trip,\n                    route,\n                    segment,\n                    currentSeconds\n                });\n            }\n        });\n\n        return activeBuses;\n    }\n\n    /**\n     * Trouve le segment (paire d'arr√™ts) o√π se trouve le bus actuellement\n     */\n    findCurrentSegment(stopTimes, currentSeconds) {\n        for (let i = 0; i < stopTimes.length - 1; i++) {\n            const currentStop = stopTimes[i];\n            const nextStop = stopTimes[i + 1];\n\n            const departureTime = this.dataManager.timeToSeconds(\n                currentStop.departure_time || currentStop.arrival_time\n            );\n            const arrivalTime = this.dataManager.timeToSeconds(\n                nextStop.arrival_time || nextStop.departure_time\n            );\n\n            // Le bus est entre ces deux arr√™ts\n            if (currentSeconds >= departureTime && currentSeconds <= arrivalTime) {\n                return {\n                    fromStop: currentStop,\n                    toStop: nextStop,\n                    fromStopInfo: this.dataManager.getStop(currentStop.stop_id),\n                    toStopInfo: this.dataManager.getStop(nextStop.stop_id),\n                    departureTime,\n                    arrivalTime,\n                    progress: this.calculateProgress(departureTime, arrivalTime, currentSeconds)\n                };\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Calcule la progression entre deux arr√™ts (0 √† 1)\n     */\n    calculateProgress(departureTime, arrivalTime, currentTime) {\n        const totalDuration = arrivalTime - departureTime;\n        if (totalDuration === 0) return 0;\n\n        const elapsed = currentTime - departureTime;\n        return Math.max(0, Math.min(1, elapsed / totalDuration));\n    }\n\n    /**\n     * Estime le temps d'arriv√©e au prochain arr√™t\n     */\n    getNextStopETA(segment, currentSeconds) {\n        if (!segment) return null;\n\n        const remainingSeconds = segment.arrivalTime - currentSeconds;\n        const minutes = Math.floor(remainingSeconds / 60);\n        const seconds = Math.floor(remainingSeconds % 60);\n\n        return {\n            seconds: remainingSeconds,\n            formatted: `${minutes}m ${seconds}s`\n        };\n    }\n\n    /**\n     * R√©cup√®re la destination finale d'un trip\n     */\n    getTripDestination(stopTimes) {\n        if (!stopTimes || stopTimes.length === 0) {\n            return 'Destination inconnue';\n        }\n\n        const lastStop = stopTimes[stopTimes.length - 1];\n        const stopInfo = this.dataManager.getStop(lastStop.stop_id);\n        \n        return stopInfo ? stopInfo.stop_name : lastStop.stop_id;\n    }\n}\n","size_bytes":3543},"public/js/dataManager.js":{"content":"/**\n * dataManager.js\n * \n * G√®re le chargement et le parsing des donn√©es GTFS et GeoJSON\n * \n * IMPORTANT: Placez vos fichiers GTFS dans /public/data/gtfs/\n * - routes.txt\n * - trips.txt\n * - stop_times.txt\n * - stops.txt\n * - calendar.txt (optionnel)\n * \n * Placez votre fichier GeoJSON dans /public/data/map.geojson\n */\n\nexport class DataManager {\n    constructor() {\n        this.routes = [];\n        this.trips = [];\n        this.stopTimes = [];\n        this.stops = [];\n        this.geoJson = null;\n        this.isLoaded = false;\n    }\n\n    /**\n     * Charge tous les fichiers GTFS et GeoJSON\n     */\n    async loadAllData() {\n        try {\n            console.log('üì¶ Chargement des donn√©es GTFS et GeoJSON...');\n            \n            // Charger les fichiers GTFS en parall√®le\n            const [routes, trips, stopTimes, stops, geoJson] = await Promise.all([\n                this.loadGTFSFile('routes.txt'),\n                this.loadGTFSFile('trips.txt'),\n                this.loadGTFSFile('stop_times.txt'),\n                this.loadGTFSFile('stops.txt'),\n                this.loadGeoJSON()\n            ]);\n\n            this.routes = routes;\n            this.trips = trips;\n            this.stopTimes = stopTimes;\n            this.stops = stops;\n            this.geoJson = geoJson;\n\n            // V√©rifier que les fichiers critiques ont des donn√©es\n            const hasCriticalData = routes.length > 0 && trips.length > 0 && \n                                   stopTimes.length > 0 && stops.length > 0;\n\n            if (!hasCriticalData) {\n                const missingFiles = [];\n                if (routes.length === 0) missingFiles.push('routes.txt');\n                if (trips.length === 0) missingFiles.push('trips.txt');\n                if (stopTimes.length === 0) missingFiles.push('stop_times.txt');\n                if (stops.length === 0) missingFiles.push('stops.txt');\n                \n                throw new Error(`Fichiers GTFS manquants ou vides: ${missingFiles.join(', ')}. Placez vos fichiers dans /public/data/gtfs/`);\n            }\n\n            // Cr√©er des index pour un acc√®s rapide\n            this.indexData();\n\n            this.isLoaded = true;\n            console.log('‚úÖ Donn√©es charg√©es avec succ√®s!');\n            console.log(`   - ${this.routes.length} routes`);\n            console.log(`   - ${this.trips.length} trips`);\n            console.log(`   - ${this.stopTimes.length} stop_times`);\n            console.log(`   - ${this.stops.length} stops`);\n            \n            return true;\n        } catch (error) {\n            console.error('‚ùå Erreur lors du chargement des donn√©es:', error);\n            this.isLoaded = false;\n            throw error;\n        }\n    }\n\n    /**\n     * Charge un fichier GTFS CSV\n     */\n    async loadGTFSFile(filename) {\n        const path = `data/gtfs/${filename}`;\n        \n        try {\n            const response = await fetch(path);\n            if (!response.ok) {\n                throw new Error(`Impossible de charger ${filename} (${response.status})`);\n            }\n            \n            const csvText = await response.text();\n            \n            return new Promise((resolve, reject) => {\n                Papa.parse(csvText, {\n                    header: true,\n                    skipEmptyLines: true,\n                    complete: (results) => {\n                        console.log(`‚úì ${filename}: ${results.data.length} lignes`);\n                        resolve(results.data);\n                    },\n                    error: (error) => {\n                        reject(error);\n                    }\n                });\n            });\n        } catch (error) {\n            console.warn(`‚ö†Ô∏è ${filename} non trouv√© ou erreur:`, error.message);\n            return [];\n        }\n    }\n\n    /**\n     * Charge le fichier GeoJSON\n     */\n    async loadGeoJSON() {\n        try {\n            const response = await fetch('data/map.geojson');\n            if (!response.ok) {\n                throw new Error(`Impossible de charger map.geojson (${response.status})`);\n            }\n            \n            const data = await response.json();\n            console.log('‚úì GeoJSON charg√©');\n            return data;\n        } catch (error) {\n            console.warn('‚ö†Ô∏è map.geojson non trouv√©:', error.message);\n            return null;\n        }\n    }\n\n    /**\n     * Cr√©e des index pour un acc√®s rapide aux donn√©es\n     */\n    indexData() {\n        // Index des routes par route_id\n        this.routesById = {};\n        this.routes.forEach(route => {\n            this.routesById[route.route_id] = route;\n        });\n\n        // Index des trips par trip_id et par route_id\n        this.tripsById = {};\n        this.tripsByRoute = {};\n        this.trips.forEach(trip => {\n            this.tripsById[trip.trip_id] = trip;\n            \n            const routeId = trip.route_id;\n            if (!this.tripsByRoute[routeId]) {\n                this.tripsByRoute[routeId] = [];\n            }\n            this.tripsByRoute[routeId].push(trip);\n        });\n\n        // Index des stop_times par trip_id (tri√©s par stop_sequence)\n        this.stopTimesByTrip = {};\n        this.stopTimes.forEach(stopTime => {\n            const tripId = stopTime.trip_id;\n            if (!this.stopTimesByTrip[tripId]) {\n                this.stopTimesByTrip[tripId] = [];\n            }\n            this.stopTimesByTrip[tripId].push(stopTime);\n        });\n\n        // Trier les stop_times par stop_sequence\n        Object.keys(this.stopTimesByTrip).forEach(tripId => {\n            this.stopTimesByTrip[tripId].sort((a, b) => {\n                return parseInt(a.stop_sequence) - parseInt(b.stop_sequence);\n            });\n        });\n\n        // Index des stops par stop_id\n        this.stopsById = {};\n        this.stops.forEach(stop => {\n            this.stopsById[stop.stop_id] = stop;\n        });\n\n        console.log('‚úì Index cr√©√©s');\n    }\n\n    /**\n     * Convertit une heure GTFS (HH:MM:SS) en secondes depuis minuit\n     */\n    timeToSeconds(timeString) {\n        if (!timeString) return 0;\n        \n        const parts = timeString.split(':');\n        const hours = parseInt(parts[0]);\n        const minutes = parseInt(parts[1]);\n        const seconds = parseInt(parts[2] || 0);\n        \n        return hours * 3600 + minutes * 60 + seconds;\n    }\n\n    /**\n     * Convertit des secondes en format HH:MM:SS\n     */\n    secondsToTime(seconds) {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor((seconds % 3600) / 60);\n        const secs = seconds % 60;\n        \n        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;\n    }\n\n    /**\n     * R√©cup√®re tous les trips actifs √† un moment donn√©\n     */\n    getActiveTrips(currentSeconds) {\n        const activeTrips = [];\n\n        Object.keys(this.stopTimesByTrip).forEach(tripId => {\n            const stopTimes = this.stopTimesByTrip[tripId];\n            if (stopTimes.length < 2) return;\n\n            const firstStop = stopTimes[0];\n            const lastStop = stopTimes[stopTimes.length - 1];\n\n            const startTime = this.timeToSeconds(firstStop.departure_time || firstStop.arrival_time);\n            const endTime = this.timeToSeconds(lastStop.arrival_time || lastStop.departure_time);\n\n            // V√©rifier si le trip est actif √† ce moment\n            if (currentSeconds >= startTime && currentSeconds <= endTime) {\n                const trip = this.tripsById[tripId];\n                if (trip) {\n                    activeTrips.push({\n                        tripId,\n                        trip,\n                        stopTimes,\n                        route: this.routesById[trip.route_id]\n                    });\n                }\n            }\n        });\n\n        return activeTrips;\n    }\n\n    /**\n     * R√©cup√®re les informations d'un arr√™t par son ID\n     */\n    getStop(stopId) {\n        return this.stopsById[stopId];\n    }\n\n    /**\n     * R√©cup√®re les informations d'une route par son ID\n     */\n    getRoute(routeId) {\n        return this.routesById[routeId];\n    }\n\n    /**\n     * R√©cup√®re le trac√© GeoJSON d'une route par son route_id\n     */\n    getRouteGeometry(routeId) {\n        if (!this.geoJson || !this.geoJson.features) {\n            return null;\n        }\n\n        // Chercher le feature GeoJSON correspondant √† cette route\n        const feature = this.geoJson.features.find(f => \n            f.properties && (\n                f.properties.route_id === routeId ||\n                f.properties.route_id === String(routeId) ||\n                f.properties.name === routeId\n            )\n        );\n\n        if (feature && feature.geometry && feature.geometry.type === 'LineString') {\n            return feature.geometry.coordinates;\n        }\n\n        return null;\n    }\n\n    /**\n     * Trouve le point le plus proche sur un trac√© GeoJSON\n     */\n    findNearestPointOnRoute(coordinates, targetLat, targetLon) {\n        if (!coordinates || coordinates.length === 0) {\n            return null;\n        }\n\n        let minDistance = Infinity;\n        let nearestIndex = 0;\n\n        coordinates.forEach((coord, index) => {\n            const [lon, lat] = coord;\n            const distance = this.calculateDistance(targetLat, targetLon, lat, lon);\n            \n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestIndex = index;\n            }\n        });\n\n        return nearestIndex;\n    }\n\n    /**\n     * Calcule la distance entre deux points g√©ographiques (formule de Haversine)\n     */\n    calculateDistance(lat1, lon1, lat2, lon2) {\n        const R = 6371; // Rayon de la Terre en km\n        const dLat = this.toRad(lat2 - lat1);\n        const dLon = this.toRad(lon2 - lon1);\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        \n        return distance;\n    }\n\n    /**\n     * Convertit des degr√©s en radians\n     */\n    toRad(degrees) {\n        return degrees * Math.PI / 180;\n    }\n}\n","size_bytes":10314},"public/style.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --primary: #2563eb;\n    --primary-dark: #1d4ed8;\n    --secondary: #64748b;\n    --bg-main: #ffffff;\n    --bg-secondary: #f8fafc;\n    --text-primary: #0f172a;\n    --text-secondary: #64748b;\n    --border: #e2e8f0;\n    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);\n    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);\n    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n    background: var(--bg-secondary);\n    overflow: hidden;\n    color: var(--text-primary);\n}\n\n#app {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n}\n\n/* Header */\nheader {\n    background: var(--bg-main);\n    border-bottom: 1px solid var(--border);\n    padding: 0.875rem 1.5rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.header-title {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n}\n\n.header-title svg {\n    color: var(--primary);\n}\n\nheader h1 {\n    font-size: 1.25rem;\n    font-weight: 600;\n    color: var(--text-primary);\n}\n\n#clock {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    font-size: 0.95rem;\n    font-weight: 500;\n    font-variant-numeric: tabular-nums;\n    color: var(--text-secondary);\n}\n\n#clock svg {\n    opacity: 0.7;\n}\n\n#current-time {\n    font-weight: 600;\n    color: var(--text-primary);\n}\n\n#date-indicator {\n    background: var(--bg-secondary);\n    padding: 0.25rem 0.625rem;\n    border-radius: 6px;\n    font-size: 0.8125rem;\n    border: 1px solid var(--border);\n}\n\n/* Control Panel */\n#control-panel {\n    background: var(--bg-main);\n    border-bottom: 1px solid var(--border);\n    padding: 0.875rem 1.5rem;\n    display: flex;\n    gap: 1.5rem;\n    align-items: center;\n    flex-wrap: wrap;\n    z-index: 1000;\n}\n\n.control-group {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n/* Buttons */\n.btn {\n    padding: 0.5rem 1rem;\n    border: 1px solid var(--border);\n    border-radius: 8px;\n    background: var(--bg-main);\n    color: var(--text-primary);\n    cursor: pointer;\n    font-size: 0.875rem;\n    font-weight: 500;\n    transition: all 0.15s ease;\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.btn:hover {\n    background: var(--bg-secondary);\n    border-color: var(--secondary);\n}\n\n.btn:active {\n    transform: scale(0.98);\n}\n\n.btn-primary {\n    background: var(--primary);\n    color: white;\n    border-color: var(--primary);\n}\n\n.btn-primary:hover {\n    background: var(--primary-dark);\n    border-color: var(--primary-dark);\n}\n\n#status-info {\n    margin-left: auto;\n    display: flex;\n    gap: 1.25rem;\n    font-size: 0.875rem;\n}\n\n#bus-count {\n    font-weight: 600;\n    color: var(--primary);\n    display: flex;\n    align-items: center;\n    gap: 0.375rem;\n}\n\n#data-status {\n    color: var(--text-secondary);\n}\n\n#data-status.loaded {\n    color: #059669;\n}\n\n#data-status.error {\n    color: #dc2626;\n}\n\n/* Map */\n#map {\n    flex: 1;\n    position: relative;\n}\n\n/* Instructions Panel */\n#instructions {\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: var(--bg-main);\n    padding: 2rem;\n    border-radius: 12px;\n    box-shadow: var(--shadow-lg);\n    max-width: 500px;\n    z-index: 2000;\n    border: 1px solid var(--border);\n}\n\n#instructions.hidden {\n    display: none;\n}\n\n.instruction-header {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    margin-bottom: 1.25rem;\n}\n\n.instruction-header svg {\n    color: var(--primary);\n}\n\n.instruction-header h3 {\n    margin: 0;\n    color: var(--text-primary);\n    font-size: 1.125rem;\n}\n\n#instructions ol {\n    margin-left: 1.5rem;\n    line-height: 1.8;\n    color: var(--text-primary);\n}\n\n#instructions ul {\n    margin: 0.5rem 0 0.5rem 1.5rem;\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n}\n\n#instructions code {\n    background: var(--bg-secondary);\n    padding: 0.2rem 0.5rem;\n    border-radius: 4px;\n    font-family: 'Courier New', monospace;\n    color: var(--primary);\n    font-size: 0.8125rem;\n    border: 1px solid var(--border);\n}\n\n#close-instructions {\n    margin-top: 1.5rem;\n    padding: 0.5rem 1.25rem;\n    background: var(--primary);\n    color: white;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-weight: 500;\n    transition: all 0.15s ease;\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n#close-instructions:hover {\n    background: var(--primary-dark);\n}\n\n/* Leaflet Popup Customization */\n.leaflet-popup-content-wrapper {\n    border-radius: 10px;\n    box-shadow: var(--shadow-md);\n    border: 1px solid var(--border);\n}\n\n.bus-popup {\n    min-width: 200px;\n}\n\n.bus-popup h4 {\n    margin: 0 0 0.75rem 0;\n    color: var(--primary);\n    font-size: 1rem;\n    font-weight: 600;\n}\n\n.bus-popup p {\n    margin: 0.5rem 0;\n    font-size: 0.875rem;\n    color: var(--text-primary);\n}\n\n.bus-popup strong {\n    color: var(--text-primary);\n    font-weight: 600;\n}\n\n/* Custom Bus Icon */\n.bus-icon-rect {\n    transition: transform 0.2s ease;\n}\n\n.bus-icon-rect:hover {\n    transform: scale(1.15);\n    z-index: 1000 !important;\n}\n\n/* Route Lines */\n.route-line {\n    stroke-width: 3;\n    stroke-opacity: 0.7;\n    fill: none;\n}\n\n.route-line.highlighted {\n    stroke-width: 5;\n    stroke-opacity: 1;\n    z-index: 1000;\n}\n\n/* Loading Overlay */\n.loading-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(255,255,255,0.95);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 3000;\n    font-size: 1.25rem;\n    color: var(--primary);\n    font-weight: 500;\n}\n\n/* Route Filter Panel */\n#route-filter-panel {\n    position: fixed;\n    top: 180px;\n    right: 20px;\n    width: 320px;\n    max-height: 70vh;\n    background: var(--bg-main);\n    border-radius: 12px;\n    box-shadow: var(--shadow-lg);\n    border: 1px solid var(--border);\n    z-index: 1500;\n    display: flex;\n    flex-direction: column;\n    transition: transform 0.3s ease;\n}\n\n#route-filter-panel.hidden {\n    transform: translateX(400px);\n    pointer-events: none;\n}\n\n.filter-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 1rem 1.25rem;\n    border-bottom: 1px solid var(--border);\n    background: var(--bg-main);\n}\n\n.filter-header h3 {\n    margin: 0;\n    font-size: 1rem;\n    font-weight: 600;\n    color: var(--text-primary);\n}\n\n.btn-close {\n    background: transparent;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    padding: 0.25rem;\n    line-height: 1;\n    transition: all 0.15s ease;\n    border-radius: 6px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.btn-close:hover {\n    background: var(--bg-secondary);\n    color: var(--text-primary);\n}\n\n.filter-actions {\n    padding: 1rem 1.25rem;\n    display: flex;\n    gap: 0.5rem;\n    border-bottom: 1px solid var(--border);\n}\n\n.btn-small {\n    padding: 0.375rem 0.875rem;\n    border: 1px solid var(--border);\n    border-radius: 6px;\n    background: var(--bg-main);\n    color: var(--text-primary);\n    cursor: pointer;\n    font-size: 0.8125rem;\n    font-weight: 500;\n    transition: all 0.15s ease;\n}\n\n.btn-small:hover {\n    background: var(--primary);\n    color: white;\n    border-color: var(--primary);\n}\n\n.route-list {\n    padding: 1rem 1.25rem;\n    overflow-y: auto;\n    max-height: calc(70vh - 140px);\n}\n\n.route-checkbox-item {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    padding: 0.625rem 0.75rem;\n    margin-bottom: 0.5rem;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.15s ease;\n    border: 1px solid transparent;\n}\n\n.route-checkbox-item:hover {\n    background: var(--bg-secondary);\n    border-color: var(--border);\n}\n\n.route-checkbox-item input[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n    accent-color: var(--primary);\n}\n\n.route-badge {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    min-width: 45px;\n    padding: 0.375rem 0.625rem;\n    border-radius: 6px;\n    font-weight: 600;\n    font-size: 0.875rem;\n    color: white;\n}\n\n.route-name {\n    flex: 1;\n    font-size: 0.875rem;\n    color: var(--text-primary);\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    header {\n        flex-direction: column;\n        gap: 0.625rem;\n        padding: 1rem;\n    }\n\n    .header-title h1 {\n        font-size: 1.125rem;\n    }\n\n    #control-panel {\n        flex-direction: column;\n        gap: 0.875rem;\n        padding: 1rem;\n    }\n\n    #status-info {\n        margin-left: 0;\n        flex-direction: column;\n        gap: 0.5rem;\n    }\n\n    #instructions {\n        max-width: 90%;\n        padding: 1.5rem;\n    }\n\n    #route-filter-panel {\n        top: auto;\n        bottom: 0;\n        right: 0;\n        left: 0;\n        width: 100%;\n        max-height: 60vh;\n        border-radius: 12px 12px 0 0;\n    }\n\n    #route-filter-panel.hidden {\n        transform: translateY(100%);\n    }\n}\n","size_bytes":9086},"public/js/mapRenderer.js":{"content":"/**\n * mapRenderer.js\n * \n * G√®re l'affichage de la carte Leaflet et le rendu des bus et routes\n */\n\nexport class MapRenderer {\n    constructor(mapElementId) {\n        this.mapElementId = mapElementId;\n        this.map = null;\n        this.busMarkers = {};\n        this.routeLayer = null;\n        this.selectedRoute = null;\n        this.centerCoordinates = [45.1833, 0.7167]; // P√©rigueux\n        this.zoomLevel = 13;\n    }\n\n    /**\n     * Initialise la carte Leaflet\n     */\n    initializeMap() {\n        // Cr√©er la carte\n        this.map = L.map(this.mapElementId).setView(this.centerCoordinates, this.zoomLevel);\n\n        // Ajouter la couche OpenStreetMap\n        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n            attribution: '¬© OpenStreetMap contributors',\n            maxZoom: 19\n        }).addTo(this.map);\n\n        console.log('üó∫Ô∏è Carte initialis√©e');\n    }\n\n    /**\n     * Calcule un point d√©cal√© perpendiculairement √† un segment de ligne\n     */\n    offsetPoint(lat1, lon1, lat2, lon2, offsetMeters, index, total) {\n        const earthRadius = 6371000;\n        \n        const lat1Rad = lat1 * Math.PI / 180;\n        const lon1Rad = lon1 * Math.PI / 180;\n        const lat2Rad = lat2 * Math.PI / 180;\n        const lon2Rad = lon2 * Math.PI / 180;\n        \n        const bearing = Math.atan2(\n            Math.sin(lon2Rad - lon1Rad) * Math.cos(lat2Rad),\n            Math.cos(lat1Rad) * Math.sin(lat2Rad) - \n            Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(lon2Rad - lon1Rad)\n        );\n        \n        const perpBearing = bearing + Math.PI / 2;\n        \n        const offsetDistance = offsetMeters * (index - (total - 1) / 2);\n        const angularDistance = offsetDistance / earthRadius;\n        \n        const newLat = Math.asin(\n            Math.sin(lat1Rad) * Math.cos(angularDistance) +\n            Math.cos(lat1Rad) * Math.sin(angularDistance) * Math.cos(perpBearing)\n        );\n        \n        const newLon = lon1Rad + Math.atan2(\n            Math.sin(perpBearing) * Math.sin(angularDistance) * Math.cos(lat1Rad),\n            Math.cos(angularDistance) - Math.sin(lat1Rad) * Math.sin(newLat)\n        );\n        \n        return [newLat * 180 / Math.PI, newLon * 180 / Math.PI];\n    }\n\n    /**\n     * Cr√©e une g√©om√©trie d√©cal√©e pour une LineString\n     */\n    offsetLineString(coordinates, offsetMeters, index, total) {\n        const offsetCoords = [];\n        \n        for (let i = 0; i < coordinates.length; i++) {\n            const [lon, lat] = coordinates[i];\n            \n            let lon2, lat2;\n            if (i < coordinates.length - 1) {\n                [lon2, lat2] = coordinates[i + 1];\n            } else {\n                [lon2, lat2] = coordinates[i - 1];\n            }\n            \n            const [newLat, newLon] = this.offsetPoint(lat, lon, lat2, lon2, offsetMeters, index, total);\n            offsetCoords.push([newLon, newLat]);\n        }\n        \n        return offsetCoords;\n    }\n\n    /**\n     * Affiche les routes GeoJSON avec rendu multi-couleurs\n     * D√©cale visuellement les routes quand plusieurs lignes partagent le m√™me segment\n     */\n    displayMultiColorRoutes(geoJsonData, dataManager, visibleRoutes) {\n        if (!geoJsonData) {\n            console.warn('Aucune donn√©e GeoJSON √† afficher');\n            return;\n        }\n\n        if (this.routeLayer) {\n            this.map.removeLayer(this.routeLayer);\n        }\n\n        this.routeLayer = L.layerGroup().addTo(this.map);\n\n        const geometryMap = new Map();\n\n        geoJsonData.features.forEach(feature => {\n            if (feature.geometry && feature.geometry.type === 'LineString') {\n                const routeId = feature.properties?.route_id;\n                \n                if (!visibleRoutes.has(routeId)) {\n                    return;\n                }\n\n                const geomKey = JSON.stringify(feature.geometry.coordinates);\n                \n                if (!geometryMap.has(geomKey)) {\n                    geometryMap.set(geomKey, []);\n                }\n                geometryMap.get(geomKey).push(feature);\n            }\n        });\n\n        geometryMap.forEach((features, geomKey) => {\n            const numRoutes = features.length;\n            const baseWidth = 4;\n            const offsetMeters = 3;\n\n            if (numRoutes === 1) {\n                const feature = features[0];\n                const routeColor = feature.properties?.route_color || '#3388ff';\n                const layer = L.geoJSON(feature, {\n                    style: {\n                        color: routeColor,\n                        weight: baseWidth,\n                        opacity: 0.85,\n                        lineCap: 'round',\n                        lineJoin: 'round'\n                    }\n                });\n                this.addRoutePopup(layer, features, dataManager);\n                layer.addTo(this.routeLayer);\n            } else {\n                features.forEach((feature, index) => {\n                    const routeColor = feature.properties?.route_color || '#3388ff';\n                    \n                    const offsetCoords = this.offsetLineString(\n                        feature.geometry.coordinates,\n                        offsetMeters,\n                        index,\n                        numRoutes\n                    );\n                    \n                    const offsetFeature = {\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: offsetCoords\n                        },\n                        properties: feature.properties\n                    };\n                    \n                    const layer = L.geoJSON(offsetFeature, {\n                        style: {\n                            color: routeColor,\n                            weight: baseWidth,\n                            opacity: 0.85,\n                            lineCap: 'round',\n                            lineJoin: 'round'\n                        }\n                    });\n\n                    layer.addTo(this.routeLayer);\n                    this.addRoutePopup(layer, features, dataManager);\n                });\n            }\n        });\n\n        try {\n            const bounds = this.routeLayer.getBounds();\n            if (bounds && bounds.isValid()) {\n                this.map.fitBounds(bounds);\n            }\n        } catch (e) {\n            console.log('‚úì Routes affich√©es (zoom non ajust√©)');\n        }\n\n        console.log(`‚úì ${geometryMap.size} segments de routes affich√©es (lignes d√©cal√©es pour visibilit√©)`);\n    }\n\n    /**\n     * Ajoute un popup aux routes\n     */\n    addRoutePopup(layer, features, dataManager) {\n        layer.eachLayer(sublayer => {\n            if (features.length === 1) {\n                const props = features[0].properties;\n                const routeId = props?.route_id;\n                const route = dataManager.getRoute(routeId);\n                const routeColor = route?.route_color ? `#${route.route_color}` : props?.route_color || '#3388ff';\n                const textColor = route?.route_text_color ? `#${route.route_text_color}` : '#ffffff';\n                const routeName = route?.route_short_name || props?.route_short_name || props?.name || 'Route';\n                const routeLongName = route?.route_long_name || props?.route_long_name || '';\n                \n                const popupContent = `\n                    <div class=\"route-popup\">\n                        <div style=\"background-color: ${routeColor}; color: ${textColor}; padding: 8px; border-radius: 4px; margin-bottom: 8px; text-align: center; font-weight: bold; font-size: 1.1em;\">\n                            Ligne ${routeName}\n                        </div>\n                        ${routeLongName ? `<p style=\"margin: 5px 0;\"><strong>${routeLongName}</strong></p>` : ''}\n                    </div>\n                `;\n                sublayer.bindPopup(popupContent);\n            } else {\n                // Plusieurs lignes - afficher toutes dans le popup\n                let popupContent = '<div class=\"route-popup\"><h4>Lignes sur ce segment:</h4>';\n                features.forEach(feature => {\n                    const props = feature.properties;\n                    const routeId = props?.route_id;\n                    const route = dataManager.getRoute(routeId);\n                    const routeColor = route?.route_color ? `#${route.route_color}` : '#3388ff';\n                    const textColor = route?.route_text_color ? `#${route.route_text_color}` : '#ffffff';\n                    const routeName = route?.route_short_name || props?.route_short_name || 'Route';\n                    \n                    popupContent += `\n                        <div style=\"background-color: ${routeColor}; color: ${textColor}; padding: 4px 8px; border-radius: 3px; margin: 4px 0; text-align: center; font-weight: bold;\">\n                            Ligne ${routeName}\n                        </div>\n                    `;\n                });\n                popupContent += '</div>';\n                sublayer.bindPopup(popupContent);\n            }\n        });\n    }\n\n    /**\n     * Affiche les routes GeoJSON sur la carte (ancienne m√©thode, gard√©e pour compatibilit√©)\n     */\n    displayRoutes(geoJsonData) {\n        console.warn('displayRoutes() est d√©pr√©ci√©, utilisez displayMultiColorRoutes() √† la place');\n        if (!geoJsonData) return;\n\n        if (this.routeLayer) {\n            this.map.removeLayer(this.routeLayer);\n        }\n\n        this.routeLayer = L.geoJSON(geoJsonData, {\n            filter: (feature) => {\n                return feature.geometry && feature.geometry.type === 'LineString';\n            },\n            style: (feature) => {\n                const routeColor = feature.properties?.route_color || '#3388ff';\n                return {\n                    color: routeColor,\n                    weight: 3,\n                    opacity: 0.7\n                };\n            }\n        }).addTo(this.map);\n\n        const bounds = this.routeLayer.getBounds();\n        if (bounds.isValid()) {\n            this.map.fitBounds(bounds);\n        }\n    }\n\n    /**\n     * Surligne une route s√©lectionn√©e\n     */\n    highlightRoute(layer) {\n        // V√©rifier que le layer a une m√©thode setStyle\n        if (!layer || typeof layer.setStyle !== 'function') {\n            return;\n        }\n\n        // R√©initialiser la route pr√©c√©demment s√©lectionn√©e\n        if (this.selectedRoute && typeof this.selectedRoute.setStyle === 'function') {\n            this.selectedRoute.setStyle({\n                weight: 3,\n                opacity: 0.7\n            });\n        }\n\n        // Surligner la nouvelle route\n        layer.setStyle({\n            weight: 5,\n            opacity: 1\n        });\n\n        this.selectedRoute = layer;\n    }\n\n    /**\n     * Met √† jour l'affichage des bus sur la carte avec mise √† jour temps r√©el des popups\n     */\n    updateBusMarkers(busesWithPositions, tripScheduler, currentSeconds) {\n        const currentBusIds = new Set();\n\n        busesWithPositions.forEach(bus => {\n            const busId = bus.tripId;\n            currentBusIds.add(busId);\n\n            const { lat, lon } = bus.position;\n            \n            // Cr√©er ou mettre √† jour le marqueur\n            if (this.busMarkers[busId]) {\n                // Mettre √† jour la position existante avec animation fluide\n                this.busMarkers[busId].marker.setLatLng([lat, lon]);\n                \n                // Mettre √† jour le popup en temps r√©el si ouvert\n                if (this.busMarkers[busId].marker.isPopupOpen()) {\n                    const newPopupContent = this.createBusPopupContent(bus, tripScheduler);\n                    this.busMarkers[busId].marker.getPopup().setContent(newPopupContent);\n                }\n            } else {\n                // Cr√©er un nouveau marqueur\n                const markerData = this.createBusMarker(bus, tripScheduler);\n                this.busMarkers[busId] = markerData;\n                markerData.marker.addTo(this.map);\n            }\n        });\n\n        // Supprimer les marqueurs des bus qui ne sont plus actifs\n        Object.keys(this.busMarkers).forEach(busId => {\n            if (!currentBusIds.has(busId)) {\n                this.map.removeLayer(this.busMarkers[busId].marker);\n                delete this.busMarkers[busId];\n            }\n        });\n    }\n\n    /**\n     * Cr√©e le contenu HTML du popup pour un bus\n     */\n    createBusPopupContent(bus, tripScheduler) {\n        const route = bus.route;\n        const routeShortName = route?.route_short_name || route?.route_id || '?';\n        const routeColor = route?.route_color ? `#${route.route_color}` : '#3B82F6';\n        const textColor = route?.route_text_color ? `#${route.route_text_color}` : '#ffffff';\n        \n        const stopTimes = tripScheduler.dataManager.stopTimesByTrip[bus.tripId];\n        const destination = tripScheduler.getTripDestination(stopTimes);\n        const nextStopName = bus.segment?.toStopInfo?.stop_name || 'Inconnu';\n        const nextStopETA = tripScheduler.getNextStopETA(bus.segment, bus.currentSeconds);\n        const lineName = route?.route_long_name || route?.route_short_name || 'Ligne inconnue';\n\n        return `\n            <div class=\"bus-popup\">\n                <div style=\"background: ${routeColor}; color: ${textColor}; padding: 0.625rem 0.875rem; border-radius: 6px; margin-bottom: 0.75rem; font-weight: 600; text-align: center;\">\n                    Ligne ${routeShortName}\n                </div>\n                <p style=\"margin: 0.5rem 0; font-size: 0.875rem;\"><strong>Nom:</strong> ${lineName}</p>\n                <p style=\"margin: 0.5rem 0; font-size: 0.875rem;\"><strong>Direction:</strong> ${destination}</p>\n                <p style=\"margin: 0.5rem 0; font-size: 0.875rem;\"><strong>Prochain arr√™t:</strong> ${nextStopName}</p>\n                ${nextStopETA ? `<p style=\"margin: 0.5rem 0; font-size: 0.875rem;\"><strong>Arriv√©e:</strong> ${nextStopETA.formatted}</p>` : ''}\n                <p style=\"margin: 0.625rem 0 0 0; font-size: 0.75rem; color: #64748b;\"><em>Mise √† jour en temps r√©el</em></p>\n            </div>\n        `;\n    }\n\n    /**\n     * Cr√©e un marqueur pour un bus (rectangle arrondi)\n     */\n    createBusMarker(bus, tripScheduler) {\n        const { lat, lon } = bus.position;\n        const route = bus.route;\n        const routeShortName = route?.route_short_name || route?.route_id || '?';\n        const routeColor = route?.route_color ? `#${route.route_color}` : '#FFC107';\n\n        // Cr√©er une ic√¥ne rectangulaire arrondie avec la couleur de la ligne\n        const icon = L.divIcon({\n            className: 'bus-icon-rect',\n            html: `<div style=\"background-color: ${routeColor}; width: 40px; height: 24px; border-radius: 6px; border: 2px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.85rem; box-shadow: 0 2px 10px rgba(0,0,0,0.4); text-shadow: 0 1px 2px rgba(0,0,0,0.3);\">${routeShortName}</div>`,\n            iconSize: [40, 24],\n            iconAnchor: [20, 12]\n        });\n\n        const marker = L.marker([lat, lon], { icon });\n\n        // Cr√©er le contenu du popup\n        const popupContent = this.createBusPopupContent(bus, tripScheduler);\n        marker.bindPopup(popupContent);\n\n        // Retourner le marqueur avec les donn√©es du bus pour mise √† jour temps r√©el\n        return {\n            marker: marker,\n            bus: bus\n        };\n    }\n\n    /**\n     * Centre la carte sur une position sp√©cifique\n     */\n    centerMap(lat, lon, zoom = null) {\n        if (zoom) {\n            this.map.setView([lat, lon], zoom);\n        } else {\n            this.map.setView([lat, lon]);\n        }\n    }\n\n    /**\n     * R√©cup√®re le nombre de bus actuellement affich√©s\n     */\n    getBusCount() {\n        return Object.keys(this.busMarkers).length;\n    }\n\n    /**\n     * Nettoie tous les marqueurs\n     */\n    clearAllMarkers() {\n        Object.values(this.busMarkers).forEach(markerData => {\n            this.map.removeLayer(markerData.marker);\n        });\n        this.busMarkers = {};\n    }\n}\n","size_bytes":16246},"replit.md":{"content":"# GTFS Bus Visualization Application\n\n## Vue d'ensemble\n\nApplication web interactive de visualisation en temps r√©el des positions de bus bas√©e sur des donn√©es GTFS et GeoJSON. L'application affiche une carte OpenStreetMap avec des bus anim√©s qui se d√©placent selon leurs horaires GTFS.\n\n## Architecture du Projet\n\n```\n/\n‚îú‚îÄ‚îÄ public/                     # Fichiers statiques servis au navigateur\n‚îÇ   ‚îú‚îÄ‚îÄ index.html             # Page HTML principale\n‚îÇ   ‚îú‚îÄ‚îÄ style.css              # Styles CSS\n‚îÇ   ‚îú‚îÄ‚îÄ data/                  # Donn√©es GTFS et GeoJSON (fournis par l'utilisateur)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gtfs/              # Fichiers GTFS (routes.txt, trips.txt, etc.)\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ map.geojson        # Trac√©s des lignes de bus\n‚îÇ   ‚îî‚îÄ‚îÄ js/                    # Modules JavaScript ES6\n‚îÇ       ‚îú‚îÄ‚îÄ main.js            # Point d'entr√©e et orchestration\n‚îÇ       ‚îú‚îÄ‚îÄ dataManager.js     # Chargement et parsing GTFS/GeoJSON\n‚îÇ       ‚îú‚îÄ‚îÄ timeManager.js     # Gestion du temps simul√©\n‚îÇ       ‚îú‚îÄ‚îÄ tripScheduler.js   # Calcul des trajets actifs\n‚îÇ       ‚îú‚îÄ‚îÄ busPositionCalculator.js  # Interpolation des positions\n‚îÇ       ‚îî‚îÄ‚îÄ mapRenderer.js     # Rendu Leaflet et marqueurs\n‚îî‚îÄ‚îÄ replit.md                  # Cette documentation\n```\n\n## Technologies Utilis√©es\n\n- **Frontend**: HTML5, CSS3, JavaScript ES6 Modules\n- **Cartographie**: Leaflet.js + OpenStreetMap\n- **Parsing CSV**: PapaParse\n- **Serveur**: Python HTTP Server (pour servir les fichiers statiques)\n\n## Fonctionnalit√©s Principales\n\n1. **Carte Interactive**\n   - Zoom et d√©placement fluides\n   - Affichage des trac√©s de lignes (GeoJSON)\n   - Marqueurs anim√©s pour chaque bus actif\n\n2. **Simulation Temporelle**\n   - Horloge synchronis√©e avec les horaires GTFS\n   - Contr√¥les Play/Pause/Reset\n   - Vitesses de simulation: x1, x2, x4, x8\n   - Configuration de l'heure de d√©part\n\n3. **Informations en Temps R√©el**\n   - Popup sur clic de bus (ligne, destination, ETA)\n   - Compteur de bus actifs\n   - Indicateur de vitesse de simulation\n\n4. **Animation Fluide**\n   - Interpolation lin√©aire entre arr√™ts\n   - Mise √† jour en temps r√©el des positions\n   - Transition douce des marqueurs\n\n## Comment Utiliser\n\n1. **Pr√©parer les donn√©es**:\n   - Placer les fichiers GTFS dans `/public/data/gtfs/`\n   - Placer le fichier GeoJSON dans `/public/data/map.geojson`\n\n2. **D√©marrer l'application**:\n   - Le serveur HTTP Python est configur√© pour servir depuis `/public/`\n   - Acc√©der √† l'application via le navigateur Replit\n\n3. **Contr√¥ler la simulation**:\n   - Ajuster l'heure de d√©part si n√©cessaire\n   - Cliquer sur \"Play\" pour d√©marrer\n   - Utiliser les boutons de vitesse pour acc√©l√©rer\n   - Cliquer sur les bus pour voir leurs d√©tails\n\n## Modules JavaScript\n\n### main.js\nOrchestre toute l'application, initialise les modules, configure les √©v√©nements UI.\n\n### dataManager.js\n- Charge les fichiers GTFS (CSV) avec PapaParse\n- Charge le fichier GeoJSON\n- Cr√©e des index pour acc√®s rapide aux donn√©es\n- Fournit des m√©thodes de requ√™te pour routes, trips, stops\n\n### timeManager.js\n- G√®re le temps simul√© avec une horloge interne\n- Contr√¥les: play, pause, reset, setSpeed\n- Notifie les listeners √† chaque mise √† jour\n\n### tripScheduler.js\n- Calcule quels trips sont actifs √† un instant T\n- D√©termine entre quels arr√™ts se trouve chaque bus\n- Calcule la progression sur chaque segment\n\n### busPositionCalculator.js\n- Interpole les positions GPS le long des trac√©s GeoJSON\n- Suit les routes r√©elles au lieu d'une ligne droite entre arr√™ts\n- Fallback vers interpolation lin√©aire si pas de trac√© disponible\n- Utilise la progression pour un mouvement fluide\n- Calcule l'orientation du bus (bearing)\n\n### mapRenderer.js\n- Initialise la carte Leaflet\n- Affiche les routes GeoJSON\n- Cr√©e et met √† jour les marqueurs de bus\n- G√®re les popups et interactions\n\n## Format des Donn√©es GTFS\n\nL'application attend les fichiers GTFS standards:\n- `routes.txt` - D√©finition des lignes\n- `trips.txt` - Courses individuelles\n- `stop_times.txt` - Horaires aux arr√™ts\n- `stops.txt` - Coordonn√©es des arr√™ts\n\n## √âtat Actuel\n\n- ‚úÖ Architecture modulaire compl√®te\n- ‚úÖ Chargement GTFS et GeoJSON\n- ‚úÖ Simulation temporelle avec contr√¥les\n- ‚úÖ **Calcul des positions le long des trac√©s GeoJSON r√©els**\n- ‚úÖ **Les bus suivent les routes exactes au lieu de lignes droites**\n- ‚úÖ Rendu sur carte Leaflet\n- ‚úÖ Popups avec informations d√©taill√©es\n- ‚úÖ Interface utilisateur responsive\n\n## Derni√®res Modifications (05/11/2025)\n\n### Version 2.0 - Filtrage et Rendu Multi-Couleurs\n- üéØ **Filtrage des lignes**: Panel de filtrage avec cases √† cocher pour afficher/masquer des lignes sp√©cifiques\n- üåà **Rendu multi-couleurs des routes**: Quand plusieurs lignes partagent le m√™me segment, les couleurs sont divis√©es proportionnellement\n- ‚ö° **Mise √† jour en temps r√©el des popups**: Les informations de bus (prochain arr√™t, ETA) se mettent √† jour automatiquement sans re-clic\n- üî¢ **Recalcul dynamique**: Les dimensions des routes s'ajustent automatiquement selon le nombre de lignes visibles\n- üìä **Compteur am√©lior√©**: Affiche le nombre de bus visibles / total\n\n### Version 1.0 - Base\n- ‚ú® **Am√©lioration majeure**: Les bus suivent maintenant les trac√©s GeoJSON des routes\n- üõ£Ô∏è Interpolation intelligente le long des routes r√©elles\n- üîÑ Fallback automatique vers interpolation lin√©aire si pas de trac√© disponible\n- ‚ö° Performances optimis√©es pour flottes de taille moyenne\n- üé® **Chaque ligne affiche sa propre couleur** au lieu du bleu par d√©faut\n- üè∑Ô∏è Popups am√©lior√©s avec badge color√© de la ligne\n- üéØ Filtrage intelligent pour n'afficher que les trac√©s des routes (LineString)\n\n## Fonctionnalit√©s Avanc√©es\n\n### Filtrage des Lignes\nL'application dispose d'un panneau de filtrage accessible via le bouton \"üéØ Filtrer les lignes\". Vous pouvez :\n- Afficher/masquer des lignes sp√©cifiques en cochant/d√©cochant les cases\n- S√©lectionner toutes les lignes ou aucune avec les boutons d√©di√©s\n- Voir le nombre de bus visibles sur le total en haut de la page\n\n### Rendu Multi-Couleurs\nQuand plusieurs lignes partagent le m√™me segment de route, l'application :\n- Divise automatiquement la largeur de la route par le nombre de lignes\n- Affiche chaque ligne avec sa couleur propre c√¥te √† c√¥te\n- Recalcule les dimensions quand vous filtrez des lignes\n- Affiche toutes les lignes dans le popup quand vous cliquez sur un segment partag√©\n\n### Mise √† Jour en Temps R√©el\nLes popups de bus se mettent √† jour automatiquement toutes les secondes :\n- Le prochain arr√™t change quand le bus avance\n- L'ETA (temps d'arriv√©e estim√©) diminue en temps r√©el\n- Pas besoin de fermer et rouvrir le popup\n\n## Voies de Bus D√©di√©es\n\n**Note sur les voies de bus** : L'application utilise actuellement les trac√©s GeoJSON fournis pour positionner les bus sur la carte. Pour une repr√©sentation plus pr√©cise prenant en compte les voies de bus d√©di√©es :\n\n1. **Donn√©es GeoJSON s√©par√©es** : Cr√©ez des trac√©s GeoJSON distincts pour :\n   - Les voies de bus d√©di√©es (bus-only lanes)\n   - Les routes partag√©es avec le trafic g√©n√©ral\n\n2. **Propri√©t√©s recommand√©es** : Ajoutez dans vos fichiers GeoJSON :\n   ```json\n   {\n     \"properties\": {\n       \"route_id\": \"12\",\n       \"bus_lane\": true,\n       \"lane_type\": \"dedicated|shared|mixed\"\n     }\n   }\n   ```\n\n3. **Am√©lioration future** : Le syst√®me de rendu multi-couleurs pourrait √™tre √©tendu pour :\n   - Afficher les voies d√©di√©es avec un style distinct\n   - Calculer des temps de parcours diff√©rents selon le type de voie\n   - Prendre en compte les restrictions de circulation\n\n## Prochaines Am√©liorations Possibles\n\n- ‚úÖ ~~Support du filtrage des lignes visibles~~ (Impl√©ment√©)\n- ‚úÖ ~~Rendu multi-couleurs pour routes partag√©es~~ (Impl√©ment√©)\n- ‚úÖ ~~Mise √† jour en temps r√©el des popups~~ (Impl√©ment√©)\n- Support de calendar.txt pour filtrer par jour\n- Affichage des arr√™ts sur la carte avec popups\n- Mode replay avec timeline et historique\n- Optimisation pour tr√®s grands r√©seaux (>200 bus)\n- Export de captures d'√©tat et statistiques\n- Gestion des voies de bus d√©di√©es avec trac√©s s√©par√©s\n- Calcul de temps de parcours bas√© sur le trafic\n","size_bytes":8333}},"version":2}